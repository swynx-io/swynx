/**
 * Markdown Renderer
 *
 * Renders action lists and progress reports as Markdown.
 */

/**
 * Render action list as Markdown
 */
export function renderActionListMarkdown(actionList) {
  const { meta, summary, issues, quickWins } = actionList;

  const lines = [];

  // Header
  lines.push('# Swynx Action List');
  lines.push('');
  lines.push(`**Project:** ${meta.project}`);
  lines.push(`**Path:** ${meta.path}`);
  lines.push(`**Scan Date:** ${formatDate(meta.scanDate)}`);
  lines.push(`**Scan ID:** ${meta.scanId}`);
  lines.push(`**Health Score:** ${meta.healthScore} / 100${meta.grade ? ` (${meta.grade})` : ''}`);
  lines.push('');
  lines.push('---');
  lines.push('');

  // Summary table
  lines.push('## Summary');
  lines.push('');
  lines.push('| Severity | Count |');
  lines.push('|----------|-------|');
  lines.push(`| Critical | ${summary.critical} |`);
  lines.push(`| High | ${summary.high} |`);
  lines.push(`| Medium | ${summary.medium} |`);
  lines.push(`| Low | ${summary.low} |`);
  lines.push(`| **Total** | **${summary.total}** |`);
  lines.push('');
  lines.push('---');
  lines.push('');

  // Issues by severity
  const severities = ['critical', 'high', 'medium', 'low'];

  for (const severity of severities) {
    const sevIssues = issues.filter(i => i.severity === severity);
    if (sevIssues.length === 0) continue;

    lines.push(`## ${capitalize(severity)} (${sevIssues.length})`);
    lines.push('');

    // Group by category
    const byCategory = groupBy(sevIssues, 'category');

    for (const [category, catIssues] of Object.entries(byCategory)) {
      lines.push(`### ${formatCategory(category)}`);
      lines.push('');

      for (const issue of catIssues) {
        lines.push(`- [ ] **${issue.title}**`);

        if (issue.description) {
          lines.push(`  - ${issue.description}`);
        }

        if (issue.cve) {
          lines.push(`  - ${issue.cve}`);
        }

        if (issue.exploitable !== undefined) {
          lines.push(`  - Actually exploitable: ${issue.exploitable ? 'YES' : 'NO'}${issue.usageLocations?.length ? ` â€” called at \`${issue.usageLocations[0]}\`` : ''}`);
        }

        if (issue.file && issue.file !== 'package.json') {
          lines.push(`  - File: \`${issue.file}\``);
        }

        if (issue.locations?.length) {
          for (const loc of issue.locations) {
            lines.push(`  - Location: \`${loc.file}:${loc.start}-${loc.end}\``);
          }
        }

        if (issue.impact?.cost) {
          lines.push(`  - Annual waste: Â£${issue.impact.cost.toFixed(2)}${issue.impact.co2 ? ` + ${issue.impact.co2.toFixed(1)} kg COâ‚‚` : ''}`);
        }

        if (issue.fix?.command) {
          lines.push(`  - Fix: \`${issue.fix.command}\``);
        }

        lines.push('');
      }
    }

    lines.push('---');
    lines.push('');
  }

  // Quick wins
  if (quickWins?.length > 0) {
    lines.push('## Quick Wins (Top 5 by Impact)');
    lines.push('');
    lines.push('| Issue | Effort | Impact | Fix |');
    lines.push('|-------|--------|--------|-----|');

    for (const issue of quickWins) {
      const impact = issue.impact?.cost
        ? `Â£${issue.impact.cost.toFixed(0)}/year`
        : issue.impact?.bytes
          ? formatBytes(issue.impact.bytes)
          : issue.impact?.security || '-';

      lines.push(`| ${issue.title} | ${issue.fix?.effort || '-'} | ${impact} | \`${issue.fix?.command || '-'}\` |`);
    }

    lines.push('');
    lines.push('---');
    lines.push('');
  }

  // Footer
  lines.push(`*Generated by Swynx v${meta.peerAuditVersion || '1.0.0'}*`);
  lines.push('*https://swynx.oynk.co.uk*');

  return lines.join('\n');
}

/**
 * Render progress report (diff) as Markdown
 */
export function renderProgressMarkdown(progressReport) {
  const { meta, summary, resolved, stillOpen, new: newIssues, nextActions } = progressReport;

  const lines = [];

  // Header
  lines.push('# Swynx Progress Report');
  lines.push('');
  lines.push(`**Project:** ${meta.project}`);
  lines.push(`**Current Scan:** ${meta.currentScan.id} (${formatDate(meta.currentScan.date)})`);
  lines.push(`**Previous Scan:** ${meta.previousScan.id} (${formatDate(meta.previousScan.date)})`);

  const healthSymbol = meta.healthChange >= 0 ? '+' : '';
  lines.push(`**Health Score:** ${meta.previousScan.healthScore} â†’ ${meta.currentScan.healthScore} (${healthSymbol}${meta.healthChange})`);
  lines.push('');
  lines.push('---');
  lines.push('');

  // Summary
  lines.push('## Summary');
  lines.push('');
  lines.push('| Status | Count |');
  lines.push('|--------|-------|');
  lines.push(`| âœ“ Resolved | ${summary.resolved} |`);
  lines.push(`| âœ— Still Open | ${summary.stillOpen} |`);
  lines.push(`| ðŸ†• New | ${summary.new} |`);
  lines.push('');
  lines.push(`**Progress:** ${summary.progressPercent}% of issues resolved since last scan`);
  lines.push('');
  lines.push('---');
  lines.push('');

  // Resolved
  if (resolved.length > 0) {
    lines.push(`## âœ“ Resolved (${resolved.length})`);
    lines.push('');
    lines.push('These issues were fixed since the last scan:');
    lines.push('');

    const byCategory = groupBy(resolved, 'category');
    for (const [category, issues] of Object.entries(byCategory)) {
      lines.push(`### ${formatCategory(category)}`);
      for (const issue of issues) {
        lines.push(`- [x] ~~${issue.title}~~ âœ“`);
      }
      lines.push('');
    }

    lines.push('---');
    lines.push('');
  }

  // Still Open
  if (stillOpen.length > 0) {
    lines.push(`## âœ— Still Open (${stillOpen.length})`);
    lines.push('');
    lines.push('These issues remain from the previous scan:');
    lines.push('');

    // Group by severity
    const bySeverity = groupBy(stillOpen, 'severity');

    for (const severity of ['critical', 'high', 'medium', 'low']) {
      const issues = bySeverity[severity] || [];
      if (issues.length === 0) continue;

      lines.push(`### ${capitalize(severity)} (${issues.length})`);
      lines.push('');

      for (const issue of issues.slice(0, 10)) { // Limit for readability
        lines.push(`- [ ] **${issue.title}**`);
        if (issue.daysOpen) {
          lines.push(`  - Days open: ${issue.daysOpen}`);
        }
        if (issue.fix?.command) {
          lines.push(`  - Fix: \`${issue.fix.command}\``);
        }
        lines.push('');
      }

      if (issues.length > 10) {
        lines.push(`*...and ${issues.length - 10} more ${severity} issues*`);
        lines.push('');
      }
    }

    lines.push('---');
    lines.push('');
  }

  // New Issues
  if (newIssues.length > 0) {
    lines.push(`## ðŸ†• New Issues (${newIssues.length})`);
    lines.push('');
    lines.push('These issues appeared since the last scan:');
    lines.push('');

    const bySeverity = groupBy(newIssues, 'severity');

    for (const severity of ['critical', 'high', 'medium', 'low']) {
      const issues = bySeverity[severity] || [];
      if (issues.length === 0) continue;

      lines.push(`### ${capitalize(severity)}`);
      lines.push('');

      for (const issue of issues) {
        lines.push(`- [ ] ðŸ†• **${issue.title}**`);
        if (issue.description) {
          lines.push(`  - ${issue.description}`);
        }
        if (issue.fix?.command) {
          lines.push(`  - Fix: \`${issue.fix.command}\``);
        }
        lines.push('');
      }
    }

    lines.push('---');
    lines.push('');
  }

  // Next Actions
  if (nextActions?.length > 0) {
    lines.push('## Next Actions (Recommended Priority)');
    lines.push('');

    for (let i = 0; i < nextActions.length; i++) {
      const { issue, reason } = nextActions[i];
      lines.push(`${i + 1}. **${issue.title}** â€” ${reason}${issue.fix?.effort ? `, ${issue.fix.effort} effort` : ''}`);
    }

    lines.push('');
    lines.push('---');
    lines.push('');
  }

  // Footer
  lines.push(`*Generated by Swynx v1.0.0*`);
  lines.push(`*Comparing ${meta.currentScan.id} against ${meta.previousScan.id}*`);

  return lines.join('\n');
}

// Helper functions
function formatDate(dateStr) {
  if (!dateStr) return 'Unknown';
  const d = new Date(dateStr);
  return d.toLocaleDateString('en-GB', {
    day: 'numeric',
    month: 'long',
    year: 'numeric',
    hour: '2-digit',
    minute: '2-digit'
  });
}

function capitalize(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}

function formatCategory(cat) {
  return cat.split('-').map(capitalize).join(' ');
}

function formatBytes(bytes) {
  if (!bytes) return '0 B';
  const k = 1024;
  const sizes = ['B', 'KB', 'MB', 'GB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
}

function groupBy(arr, key) {
  return arr.reduce((acc, item) => {
    const k = item[key];
    if (!acc[k]) acc[k] = [];
    acc[k].push(item);
    return acc;
  }, {});
}

export default {
  renderActionListMarkdown,
  renderProgressMarkdown
};
