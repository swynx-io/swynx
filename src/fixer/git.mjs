// src/fixer/git.mjs
// Generate git commits after fixes

import { execSync, exec } from 'child_process';
import { promisify } from 'util';

const execAsync = promisify(exec);

/**
 * Check if project is a git repository
 */
export function isGitRepo(projectPath) {
  try {
    execSync('git rev-parse --is-inside-work-tree', {
      cwd: projectPath,
      stdio: 'pipe'
    });
    return true;
  } catch {
    return false;
  }
}

/**
 * Get current git status
 */
export async function getStatus(projectPath) {
  try {
    const { stdout } = await execAsync('git status --porcelain', {
      cwd: projectPath
    });

    const lines = stdout.trim().split('\n').filter(Boolean);
    const deleted = [];
    const modified = [];
    const untracked = [];

    for (const line of lines) {
      const status = line.substring(0, 2);
      const file = line.substring(3);

      if (status.includes('D')) {
        deleted.push(file);
      } else if (status.includes('M')) {
        modified.push(file);
      } else if (status === '??') {
        untracked.push(file);
      }
    }

    return { deleted, modified, untracked };
  } catch (error) {
    return { error: error.message };
  }
}

/**
 * Stage deleted files
 */
export async function stageDeleted(projectPath, files) {
  if (files.length === 0) return { success: true, staged: 0 };

  try {
    // Stage each deleted file
    for (const file of files) {
      await execAsync(`git add "${file}"`, { cwd: projectPath });
    }
    return { success: true, staged: files.length };
  } catch (error) {
    return { success: false, error: error.message };
  }
}

/**
 * Stage modified files (import cleanups)
 */
export async function stageModified(projectPath, files) {
  if (files.length === 0) return { success: true, staged: 0 };

  try {
    for (const file of files) {
      await execAsync(`git add "${file}"`, { cwd: projectPath });
    }
    return { success: true, staged: files.length };
  } catch (error) {
    return { success: false, error: error.message };
  }
}

/**
 * Create a commit with the fix changes
 */
export async function createCommit(projectPath, options = {}) {
  const {
    deletedCount = 0,
    modifiedCount = 0,
    totalBytes = 0,
    dryRun = false
  } = options;

  // Format size
  const sizeKb = Math.round(totalBytes / 1024);
  const sizeStr = sizeKb > 1024
    ? `${(sizeKb / 1024).toFixed(1)} MB`
    : `${sizeKb} KB`;

  // Build commit message
  const summary = [];
  if (deletedCount > 0) {
    summary.push(`${deletedCount} dead file${deletedCount > 1 ? 's' : ''}`);
  }
  if (modifiedCount > 0) {
    summary.push(`${modifiedCount} import${modifiedCount > 1 ? 's' : ''} cleaned`);
  }

  const title = `chore: remove dead code (${summary.join(', ')})`;

  const body = [
    '',
    `Removed ${deletedCount} unused file${deletedCount > 1 ? 's' : ''} (${sizeStr})`,
    modifiedCount > 0 ? `Updated ${modifiedCount} file${modifiedCount > 1 ? 's' : ''} to remove dead imports` : null,
    '',
    'Generated by Swynx dead code analyzer',
    'https://swynx.io'
  ].filter(Boolean).join('\n');

  const message = title + '\n' + body;

  if (dryRun) {
    return {
      success: true,
      dryRun: true,
      message,
      wouldCommit: { deletedCount, modifiedCount }
    };
  }

  try {
    // Check if there are staged changes
    const { stdout: staged } = await execAsync('git diff --cached --name-only', { cwd: projectPath });

    if (!staged.trim()) {
      return {
        success: false,
        error: 'No staged changes to commit'
      };
    }

    // Create commit
    await execAsync(`git commit -m "${message.replace(/"/g, '\\"')}"`, {
      cwd: projectPath
    });

    return {
      success: true,
      message,
      committed: { deletedCount, modifiedCount }
    };
  } catch (error) {
    return {
      success: false,
      error: error.message
    };
  }
}

/**
 * Full workflow: stage and commit all changes
 */
export async function commitFix(projectPath, result, options = {}) {
  const { dryRun = false } = options;

  if (!isGitRepo(projectPath)) {
    return {
      success: false,
      error: 'Not a git repository',
      skipped: true
    };
  }

  const deletedFiles = (result.deleted || []).map(d => d.file || d);
  const modifiedFiles = result.filesModified || [];
  const totalBytes = (result.deleted || []).reduce((sum, d) => sum + (d.size || 0), 0);

  // Stage deleted files
  const stageDeletedResult = await stageDeleted(projectPath, deletedFiles);
  if (!stageDeletedResult.success) {
    return { success: false, error: `Failed to stage deleted files: ${stageDeletedResult.error}` };
  }

  // Stage modified files
  const stageModifiedResult = await stageModified(projectPath, modifiedFiles);
  if (!stageModifiedResult.success) {
    return { success: false, error: `Failed to stage modified files: ${stageModifiedResult.error}` };
  }

  // Create commit
  return await createCommit(projectPath, {
    deletedCount: deletedFiles.length,
    modifiedCount: modifiedFiles.length,
    totalBytes,
    dryRun
  });
}

export default {
  isGitRepo,
  getStatus,
  stageDeleted,
  stageModified,
  createCommit,
  commitFix
};
